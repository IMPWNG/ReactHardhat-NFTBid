{"ast":null,"code":"import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction updateTreeLayoutMeasurements(visualElement, isRelativeDrag) {\n  withoutTreeTransform(visualElement, function () {\n    var allChildren = collectProjectingChildren(visualElement);\n    batchResetAndMeasure(allChildren);\n    updateLayoutMeasurement(visualElement);\n  });\n  !isRelativeDrag && visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n}\n\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n\n  var addChild = function (child) {\n    if (child.projection.isEnabled || child.shouldResetTransform()) {\n      children.push(child);\n    }\n\n    child.children.forEach(addChild);\n  };\n\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Perform the callback after temporarily unapplying the transform\n * upwards through the tree.\n */\n\n\nfunction withoutTreeTransform(visualElement, callback) {\n  var parent = visualElement.parent;\n  var isEnabled = visualElement.projection.isEnabled;\n  var shouldReset = isEnabled || visualElement.shouldResetTransform();\n  shouldReset && visualElement.resetTransform();\n  parent ? withoutTreeTransform(parent, callback) : callback();\n  shouldReset && visualElement.restoreTransform();\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\n\n\nfunction updateLayoutMeasurement(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync.update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\n\n\nfunction snapshotViewportBox(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction batchResetAndMeasure(order) {\n  /**\n   * Write: Reset any transforms on children elements so we can read their actual layout\n   */\n  order.forEach(function (child) {\n    return child.resetTransform();\n  });\n  /**\n   * Read: Measure the actual layout\n   */\n\n  order.forEach(updateLayoutMeasurement);\n}\n\nexport { batchResetAndMeasure, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement, updateTreeLayoutMeasurements, withoutTreeTransform };","map":{"version":3,"sources":["/Users/ma/Desktop/ReactHardhat-NFTBid/frontend/node_modules/framer-motion/dist/es/render/dom/projection/utils.js"],"names":["sync","copyAxisBox","compareByDepth","updateTreeLayoutMeasurements","visualElement","isRelativeDrag","withoutTreeTransform","allChildren","collectProjectingChildren","batchResetAndMeasure","updateLayoutMeasurement","rebaseProjectionTarget","measureViewportBox","children","addChild","child","projection","isEnabled","shouldResetTransform","push","forEach","sort","callback","parent","shouldReset","resetTransform","restoreTransform","layoutState","getLayoutState","notifyBeforeLayoutMeasure","layout","isHydrated","layoutCorrected","notifyLayoutMeasure","prevViewportBox","update","snapshotViewportBox","order"],"mappings":"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","sourcesContent":["import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction updateTreeLayoutMeasurements(visualElement, isRelativeDrag) {\n    withoutTreeTransform(visualElement, function () {\n        var allChildren = collectProjectingChildren(visualElement);\n        batchResetAndMeasure(allChildren);\n        updateLayoutMeasurement(visualElement);\n    });\n    !isRelativeDrag &&\n        visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (child.projection.isEnabled || child.shouldResetTransform()) {\n            children.push(child);\n        }\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Perform the callback after temporarily unapplying the transform\n * upwards through the tree.\n */\nfunction withoutTreeTransform(visualElement, callback) {\n    var parent = visualElement.parent;\n    var isEnabled = visualElement.projection.isEnabled;\n    var shouldReset = isEnabled || visualElement.shouldResetTransform();\n    shouldReset && visualElement.resetTransform();\n    parent ? withoutTreeTransform(parent, callback) : callback();\n    shouldReset && visualElement.restoreTransform();\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync.update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\nfunction batchResetAndMeasure(order) {\n    /**\n     * Write: Reset any transforms on children elements so we can read their actual layout\n     */\n    order.forEach(function (child) { return child.resetTransform(); });\n    /**\n     * Read: Measure the actual layout\n     */\n    order.forEach(updateLayoutMeasurement);\n}\n\nexport { batchResetAndMeasure, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement, updateTreeLayoutMeasurements, withoutTreeTransform };\n"]},"metadata":{},"sourceType":"module"}