{"ast":null,"code":"var _jsxFileName = \"/Users/ma/Desktop/ReactHardhat-NFTBid/frontend/src/components/walletInfo/index.jsx\";\nimport React from \"react\"; // We'll use ethers to interact with the Ethereum network and our contract\n\nimport { ethers } from \"ethers\";\nimport TokenArtifact from \"../../contracts/Token.json\";\nimport contractAddress from \"../../contracts/contract-address.json\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class Dapp extends React.Component {\n  constructor(props) {\n    super(props); // We store multiple things in Dapp's state.\n    // You don't need to follow this pattern, but it's an useful example.\n\n    this.initialState = {\n      // The info of the token (i.e. It's Name and symbol)\n      tokenData: undefined,\n      // The user's address and balance\n      selectedAddress: undefined,\n      balance: undefined,\n      // The ID about transactions being sent, and any possible error with them\n      txBeingSent: undefined,\n      transactionError: undefined,\n      networkError: undefined\n    };\n    this.state = this.initialState;\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"container p-4\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-12\",\n          children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n            children: [this.state.tokenData.name, \" (\", this.state.tokenData.symbol, \")\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 36,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n            children: [\"Welcome \", /*#__PURE__*/_jsxDEV(\"b\", {\n              children: this.state.selectedAddress\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 40,\n              columnNumber: 37\n            }, this), \", you have\", \" \", /*#__PURE__*/_jsxDEV(\"b\", {\n              children: [this.state.balance.toString(), \" \", this.state.tokenData.symbol]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 41,\n              columnNumber: 29\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 39,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 35,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"hr\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 48,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 13\n    }, this);\n  }\n\n  componentWillUnmount() {\n    // We poll the user's balance, so we have to stop doing that when Dapp\n    // gets unmounted\n    this._stopPollingData();\n  }\n\n  async _connectWallet() {\n    // This method is run when the user clicks the Connect. It connects the\n    // dapp to the user's wallet, and initializes it.\n    // To connect to the user's wallet, we have to run this method.\n    // It returns a promise that will resolve to the user's address.\n    const [selectedAddress] = await window.ethereum.enable(); // Once we have the address, we can initialize the application.\n    // First we check the network\n\n    if (!this._checkNetwork()) {\n      return;\n    }\n\n    this._initialize(selectedAddress); // We reinitialize it whenever the user changes their account.\n\n\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      this._stopPollingData(); // `accountsChanged` event can be triggered with an undefined newAddress.\n      // This happens when the user removes the Dapp from the \"Connected\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n      // To avoid errors, we reset the dapp state \n\n\n      if (newAddress === undefined) {\n        return this._resetState();\n      }\n\n      this._initialize(newAddress);\n    }); // We reset the dapp state if the network is changed\n\n    window.ethereum.on(\"networkChanged\", ([networkId]) => {\n      this._stopPollingData();\n\n      this._resetState();\n    });\n  }\n\n  _initialize(userAddress) {\n    // This method initializes the dapp\n    // We first store the user's address in the component's state\n    this.setState({\n      selectedAddress: userAddress\n    }); // Then, we initialize ethers, fetch the token's data, and start polling\n    // for the user's balance.\n    // Fetching the token data and the user's balance are specific to this\n    // sample project, but you can reuse the same initialization pattern.\n\n    this._intializeEthers();\n\n    this._getTokenData();\n\n    this._startPollingData();\n  }\n\n  async _intializeEthers() {\n    // We first initialize ethers by creating a provider using window.ethereum\n    this._provider = new ethers.providers.Web3Provider(window.ethereum); // When, we initialize the contract using that provider and the token's\n    // artifact. You can do this same thing with your contracts.\n\n    this._token = new ethers.Contract(contractAddress.Token, TokenArtifact.abi, this._provider.getSigner(0));\n  }\n\n}","map":{"version":3,"sources":["/Users/ma/Desktop/ReactHardhat-NFTBid/frontend/src/components/walletInfo/index.jsx"],"names":["React","ethers","TokenArtifact","contractAddress","Dapp","Component","constructor","props","initialState","tokenData","undefined","selectedAddress","balance","txBeingSent","transactionError","networkError","state","render","name","symbol","toString","componentWillUnmount","_stopPollingData","_connectWallet","window","ethereum","enable","_checkNetwork","_initialize","on","newAddress","_resetState","networkId","userAddress","setState","_intializeEthers","_getTokenData","_startPollingData","_provider","providers","Web3Provider","_token","Contract","Token","abi","getSigner"],"mappings":"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","sourcesContent":["import React from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers } from \"ethers\";\n\nimport TokenArtifact from \"../../contracts/Token.json\";\nimport contractAddress from \"../../contracts/contract-address.json\";\n\nexport class Dapp extends React.Component {\n    constructor(props) {\n        super(props);\n\n        // We store multiple things in Dapp's state.\n        // You don't need to follow this pattern, but it's an useful example.\n        this.initialState = {\n            // The info of the token (i.e. It's Name and symbol)\n            tokenData: undefined,\n            // The user's address and balance\n            selectedAddress: undefined,\n            balance: undefined,\n            // The ID about transactions being sent, and any possible error with them\n            txBeingSent: undefined,\n            transactionError: undefined,\n            networkError: undefined,\n        };\n\n        this.state = this.initialState;\n    }\n\n    render() {\n\n        return (\n            <div className=\"container p-4\">\n                <div className=\"row\">\n                    <div className=\"col-12\">\n                        <h1>\n                            {this.state.tokenData.name} ({this.state.tokenData.symbol})\n            </h1>\n                        <p>\n                            Welcome <b>{this.state.selectedAddress}</b>, you have{\" \"}\n                            <b>\n                                {this.state.balance.toString()} {this.state.tokenData.symbol}\n                            </b>\n            \n            </p>\n                    </div>\n                </div>\n                <hr/>\n            </div>\n        );\n    }\n\n    componentWillUnmount() {\n        // We poll the user's balance, so we have to stop doing that when Dapp\n        // gets unmounted\n        this._stopPollingData();\n    }\n\n    async _connectWallet() {\n        // This method is run when the user clicks the Connect. It connects the\n        // dapp to the user's wallet, and initializes it.\n\n        // To connect to the user's wallet, we have to run this method.\n        // It returns a promise that will resolve to the user's address.\n        const [selectedAddress] = await window.ethereum.enable();\n\n        // Once we have the address, we can initialize the application.\n\n        // First we check the network\n        if (!this._checkNetwork()) {\n            return;\n        }\n\n        this._initialize(selectedAddress);\n\n        // We reinitialize it whenever the user changes their account.\n        window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n            this._stopPollingData();\n            // `accountsChanged` event can be triggered with an undefined newAddress.\n            // This happens when the user removes the Dapp from the \"Connected\n            // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n            // To avoid errors, we reset the dapp state \n            if (newAddress === undefined) {\n                return this._resetState();\n            }\n\n            this._initialize(newAddress);\n        });\n\n        // We reset the dapp state if the network is changed\n        window.ethereum.on(\"networkChanged\", ([networkId]) => {\n            this._stopPollingData();\n            this._resetState();\n        });\n    }\n\n    _initialize(userAddress) {\n        // This method initializes the dapp\n\n        // We first store the user's address in the component's state\n        this.setState({\n            selectedAddress: userAddress,\n        });\n\n        // Then, we initialize ethers, fetch the token's data, and start polling\n        // for the user's balance.\n\n        // Fetching the token data and the user's balance are specific to this\n        // sample project, but you can reuse the same initialization pattern.\n        this._intializeEthers();\n        this._getTokenData();\n        this._startPollingData();\n    }\n\n    async _intializeEthers() {\n        // We first initialize ethers by creating a provider using window.ethereum\n        this._provider = new ethers.providers.Web3Provider(window.ethereum);\n\n        // When, we initialize the contract using that provider and the token's\n        // artifact. You can do this same thing with your contracts.\n        this._token = new ethers.Contract(\n            contractAddress.Token,\n            TokenArtifact.abi,\n            this._provider.getSigner(0)\n        );\n    }\n\n\n    \n\n\n\n\n\n\n\n\n}\n\n\n\n"]},"metadata":{},"sourceType":"module"}